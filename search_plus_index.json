{"./":{"url":"./","title":"facebook hermes 编译","keywords":"","body":"基本环境 # 按需安装 brew install cmake git ninja # 准备workspace mkdir github_hermes_workspace cd github_hermes_workspace/ # 环境变量，很重要，编译hermes.so时，hermes/android/build.gradle工程会读取使用 export HERMES_WS_DIR=\"$(pwd)\" # clone，作为workspace子目录 git clone https://github.com/facebook/hermes.git github_hermes 编译hermesc # 构建build目录 ## 由于 hermes/android/build.gradle 里写死了路径（build|build_release），不改源码的前提下就用前述两个： ## RELEASE: cmake -S github_hermes -B build_release -G Ninja -DCMAKE_BUILD_TYPE=Release cmake -S github_hermes -B build -G Ninja # build hermesc ## --build 指定的是上述命令的输出路径 cmake --build ./build --target hermesc # hermesc位置：位于 --build 指定的目录下 find . | grep -E \"hermesc$\" 编译hermes.so 指定NDK版本，这个很重要，保证和要使用hermes的工程的版本一致（目前已发现的问题是try-catch失效），方式： android.ndkVersion （需要更改hermes/android/hermes/build.gradle） android.ndkPath （需要更改hermes/android/hermes/build.gradle） ndk.dir @ local.properties 一些说明： Intl 表示国际化版本 不管是debug还是release的libhermes.so，CMAKE_BUILD_TYPE都是为Release JS developers aren't VM developers. Give them a faster build. release的参数： HERMES_ENABLE_DEBUGGER=false // 即debug的so带inspector CMAKE_BUILD_TYPE=MinSizeRel 混淆规则： -keep class com.facebook.hermes.unicode.** { *; } -keep class com.facebook.jni.** { *; } cd hermes/android/ chmod +x gradlew # build目录在 ${HERMES_WS_DIR}/build_android/ ./gradlew build # so位置： cd $HERMES_WS_DIR find . | grep -E \"libhermes\\.so$\" js转hbc hermes -emit-binary -out test.hbc test.js 运行RN demo 参考：https://reactnative.dev/docs/environment-setup npx react-native init AwesomeProject npx react-native run-android 更多 https://hermesengine.dev/docs/cross-compilation 使用Chrome调试运行在hermes的JS代码 "},"src/tips.html":{"url":"src/tips.html","title":"创刊 · 卷首语","keywords":"","body":"基于 Gitbook 3.2.3 但谈不上感谢，毫无文档可言🙂 言归正传 当前 book 作为 linjiang.tech 博客的补充，充当一个知识小集锦的作用。 "},"src/apk-size-diff.html":{"url":"src/apk-size-diff.html","title":"raw size 和 download size 的区别","keywords":"","body":"参照官方文档 的解释： Raw File Size 表示实体在磁盘上未经压缩时的大小； Download Size 则表示实体由 Google Play 提供时估计压缩后的大小； 这是因为生成的 apk 上传至 google play 后会被再次处理（压缩）以减少网络传输数据量，待手机端下载完成后被还原为原始文件。 也就是说 raw size 就是apk的本身大小（当然也并非解压后的目录大小）； download size 就是实际下载时消耗的流量大小。 "},"src/ap.html":{"url":"src/ap.html","title":".ap_ 文件的作用","keywords":"","body":" AAPT2 将AAPT 对资源的编译拆分细化为了 compile 和 link 两个步骤，以更好地提升编译速度（增量编译）。 其中 link 的结果除了生成 R.java 外，还生成了 .ap_ 产物（本质上是zip），包含 manifest 清单、所有资源文件以及资源索引表arsc。 当执行 package-task 生成 .apk 时并不是解压.ap文件得到相关资源再与dex重新压缩，而是以 copy zip entry 的形式直接拷贝到最终的apk文件。也就是说，.ap 文件中各个entry的压缩效果与apk中一致。 "}}